<h1 id="cs2030-practical-assessment-2">CS2030 Practical Assessment #2</h1>
<p><a href="https://russelldash332.github.io/CS2030/">Back to homepage</a></p>

<h2>Random Number Generation</h2>

<p>Random numbers that are used in computer simulations are produced
via a pseudo-random generator algorithm that appears random but actually
deterministic.
Given an initial seed value, the same sequence of random values will 
always be generated.

</p><p>Once such algorithm is the linear congruential generator (LCG)
which produces pseudo-random numbers using

</p><p><i>X<sub>n+1</sub> = (a . X<sub>n</sub> + c) mod m</i>

</p><p>where given a start seed <i>X<sub>0</sub></i>, the 
sequence <i>X<sub>1</sub>, X<sub>2</sub>, ...</i> can be generated.

</p><p>As an example, when <i>a = 3</i>, <i>c = 3</i> and <i>m = 7</i>, a
seed value of <i>X<sub>0</sub> = 1</i> will generate the sequence
<i>6, 0, 3, 5, 4, 1, 6, ...</i></p>

<h2>Task</h2>

<p>Your task is to design a computation context for pseudo random number
generation, and make use of it for a simulation.

</p><h2>Take Note!</h2>

<p>This task comprises a number of levels.
You are required to complete ALL levels.</p>
In general, you should keep to the constructs and programming discipline 
instilled throughout the module.<p></p>

<p>The following are noteworthy constraints imposed on this task.

</p><ul>
<li>Write each class or interface in its own file.
DO NOT use single letter names for classes or interfaces.  DO NOT
make your classes <tt>final</tt>.
</li>
<li>Ensure that ALL object properties and class constants are declared <tt>private final</tt> <!--,
unless otherwise specified.</li>-->
</li><li>Ensure that ALL classes/interfaces are NOT cyclic dependent.</li>
<li>ONLY the following java libraries ARE allowed:
<ul>
<!--    
<li><tt>java.util.List</tt>
<li><tt>java.util.Optional</tt>
<li><tt>java.util.stream.Stream</tt>
-->
<li>functional interfaces from <tt>java.util.function</tt>
</li></ul>
</li><li>The following are NOT allowed:
<ul>
<li><tt>var</tt>, <tt>null</tt>, <tt>default</tt>, <tt>enum</tt>
</li><li><tt>instanceof</tt>
(except checking for an instance of its own class)
<!-- <li><tt>if..else</tt>, <tt>switch..case</tt>, <tt>?:</tt> conditional expression
<li><tt>for</tt>, <tt>while</tt>
<li><tt>Optional</tt> methods: <tt>isPresent</tt>, <tt>isEmpty</tt>, <tt>get</tt> and its
    variants (<tt>orElse</tt>, <tt>orElseGet</tt>, <tt>orElseThrow</tt>), as well as <tt>equals</tt>
    and <tt>hashCode</tt>
-->    
<!-- <li>methods of the <tt>String</tt> class -->
</li></ul>
</li><li>DO NOT use bounded type parameters or bounded wildcards.
</li><li>DO NOT define anonymous inner classes or method
    references <tt>::</tt><br>Define lambdas instead.
</li><li>Other usual restrictions:
<ul>
<li>Use only <tt>&amp;&amp;</tt>, <tt>||</tt> and <tt>!</tt> in logical expressions.
DO NOT use bitwise operators.
</li><li>You are NOT allowed to use <tt>*</tt> wildcard imports.
</li><li>You are NOT allowed to define array constructs, e.g.
<tt>String[]</tt> or using ellipsis, e.g.<tt>String...</tt>
</li><li>You are NOT allowed to perform string processing using methods
from <tt>String</tt>, <tt>StringBuffer</tt>,
<tt>StringBuilder</tt>, etc.
</li><li>You are NOT allowed to use exception handling
</li><li>You are NOT allowed to use Java reflection, i.e. <tt>Object::getClasses</tt> and other methods from <tt>java.lang.Class</tt>
</li></ul>
</li></ul>

<p>In the following level specifications, you will be guided on the classes and non-private methods to define.
DO NOT create any other classes.  Any other method you create must be declared <tt>private</tt>.
However, constructors can be non-private as you deem necessary.

</p><p>The following classes has been provided for you.
DO NOT replace them with your own versions.
</p><ul>
<li><tt><a href="Pair.java">Pair</a></tt> class (not a record, but
behaves similarly)
</li><li><tt><a href="Maybe.java">Maybe</a></tt> class
</li><li><tt><a href="InfList.java">InfList</a></tt> class (to be used in
level 5 only)
</li></ul>

<blockquote>
<table border="1" cellpadding="3">
<tbody><tr><td>
To automatically generate HTML documentation from the comments, issue the command:

<pre>$ javadoc -d doc InfList.java Maybe.java Pair.java
</pre>

<p>You may then navigate through the documentation from <tt>allclasses-index.html</tt> found in the <tt>doc</tt> directory.
</p></td></tr></tbody></table>
</blockquote>

<h2>Level 1</h2>

<p>Write the <tt>RandInt</tt> class with a factory method <tt>of</tt>
that takes in a function (e.g. a linear congruential generator) and returns a
<tt>RandInt</tt> object with the function encapsulated within.

</p><p>A random integer value is generated by terminating the pipeline with
the <tt>seed</tt> operation that takes in an integer as the seed
value.

</p><pre>jshell&gt; RandInt.of(x -&gt; x + 1)
$.. ==&gt; RandInt

jshell&gt; RandInt.of(x -&gt; x + 1).seed(1)
$.. ==&gt; 2

jshell&gt; RandInt.of(x -&gt; x + 1).seed(2)
$.. ==&gt; 3

jshell&gt; RandInt lcg337 = RandInt.of(x -&gt; (3 * x + 3) % 7)
lcg337 ==&gt; RandInt

jshell&gt; lcg337.seed(1)
$.. ==&gt; 6

jshell&gt; lcg337.seed(1)
$.. ==&gt; 6

jshell&gt; lcg337.seed(6)
$.. ==&gt; 0

jshell&gt; lcg337.seed(0)
$.. ==&gt; 3
</pre>

<h2>Level 2</h2>

<p>Include the <tt>map</tt> method to allow a <tt>RandInt</tt>
object to be mapped.  We first demonstrate mapping to a different integer value.

</p><pre>jshell&gt; RandInt.of(x -&gt; x + 1).map(x -&gt; x % 2).seed(1)
$.. ==&gt; 0

jshell&gt; RandInt.of(x -&gt; x + 1).map(x -&gt; x % 2).seed(2)
$.. ==&gt; 1

jshell&gt; lcg337.map(x -&gt; x % 2).seed(1)
$.. ==&gt; 0

jshell&gt; lcg337.map(x -&gt; x % 2).seed(6)
$.. ==&gt; 0

jshell&gt; lcg337.map(x -&gt; x % 2).seed(0)
$.. ==&gt; 1
</pre>

<p>From the test case of using the <tt>lcg337</tt> generator,
we observe that

</p><ul>
<li>seeding the generator with <tt>1</tt> results in the value
<tt>6</tt> (as shown in level 1), then <tt>6 % 2</tt> gives <tt>0</tt>
</li><li>seeding the generator with <tt>6</tt> results in the value
<tt>0</tt> (as shown in level 1), then <tt>0 % 2</tt> gives <tt>0</tt>
</li><li>seeding the generator with <tt>3</tt> results in the value
<tt>3</tt> (as shown in level 1), then <tt>3 % 2</tt> gives <tt>1</tt>
</li></ul>

<p>The <tt>map</tt> function should also allow mapping to a value
of any type.  For simplicity of implementation as well as grading, do
not use bounded wildcards.

</p><pre>jshell&gt; lcg337.map(x -&gt; "[" + x + "]").seed(1)
$.. ==&gt; "[6]"

jshell&gt; lcg337.map(x -&gt; "[" + x + "]").seed(6)
$.. ==&gt; "[0]"

jshell&gt; lcg337.map(x -&gt; "[" + x + "]").map(x -&gt; x.length()).seed(1)
$.. ==&gt; 3

jshell&gt; lcg337.map(x -&gt; "[" + x + "]").map(x -&gt; x.length()).seed(6)
$.. ==&gt; 3
</pre>

<p>Take note that <tt>RandInt</tt> should NOT be generic; however,
<tt>map</tt> will return a generic <tt>Rand</tt> object.

</p><pre>jshell&gt; RandInt r = lcg337
r ==&gt; RandInt

jshell&gt; RandInt&lt;Integer&gt; r = lcg337
|  Error:
|  type RandInt does not take parameters
|  RandInt&lt;Integer&gt; r = lcg337;
|  ^--------------^

jshell&gt; lcg337.map(x -&gt; "[" + x + "]")
$.. ==&gt; Rand

jshell&gt; lcg337.map(x -&gt; x + 1)
$.. ==&gt; Rand
</pre>

<p>Sample runs below demonstrate the application of the laws of the Functor involving <tt>map</tt>.

</p><pre>jshell&gt; lcg337.map(x -&gt; x).seed(1)
$.. ==&gt; 6

jshell&gt; Function&lt;Integer,String&gt; r = x -&gt; "[" + x + "]"
r ==&gt; $Lambda..

jshell&gt; Function&lt;String,String&gt; s = x -&gt; x + x
s ==&gt; $Lambda..

jshell&gt; lcg337.map(r).map(s).seed(1)
$.. ==&gt; "[6][6]"

jshell&gt; lcg337.map(s.compose(r)).seed(1)
$.. ==&gt; "[6][6]"
</pre>

<h2>Level 3</h2>

<p>So far we have generated only one random value.  
We shall now generate a sequence of random values via <tt>flatMap</tt>.

</p><pre>jshell&gt; lcg337.seed(1)
$.. ==&gt; 6

jshell&gt; lcg337.flatMap(x -&gt; lcg337).seed(1)
$.. ==&gt; 0
</pre>

<p>Here is an explanation of what happens when the above pipeline is executed.

</p><ul>
<li>The first <tt>Rand</tt> object is seeded with <tt>1</tt> and generates <tt>6</tt>
</li><li>By pipelining with a <tt>flatMap</tt>, the value of <tt>6</tt> from the first <tt>Rand</tt> object is then used as the seed for the other <tt>Rand</tt> object provided by <tt>flatMap</tt>.
</li><li>Hence, the outcome of the pipeline is <tt>0</tt>, i.e. the result
of running the <tt>lcg337</tt> generator twice with an initial seed value of <tt>1</tt>.
</li></ul>

<p>Below is an example of how we can capture the sequence of values generated as a string with <tt>map</tt>.

</p><pre>jshell&gt; lcg337.map(x -&gt; x.toString()).seed(1)
$.. ==&gt; "6"

jshell&gt; Function&lt;String,Rand&lt;String&gt;&gt; f = x -&gt; lcg337.map(y -&gt; x + y)
f ==&gt; $Lambda..

jshell&gt; lcg337.map(x -&gt; x.toString()).flatMap(f).seed(1)
$.. ==&gt; "60"

jshell&gt; lcg337.map(x -&gt; x.toString()).flatMap(f).flatMap(f).flatMap(f).seed(1)
$.. ==&gt; "6035"
</pre>

<p>Using <tt>flatMap</tt> allows us to have different random number
generator functions in a single pipeline, i.e. the value generated from the previous
generator can be used as seed for the next generator.
Below is an example showing <tt>lcg337</tt> followed by a simple
increment generator <tt>y -&gt; y + 1</tt>.

</p><pre>jshell&gt; lcg337.map(x -&gt; x.toString()).
   ...&gt; flatMap(x -&gt; RandInt.of(y -&gt; y + 1). // increment generator
   ...&gt; map(y -&gt; x + y)).seed(1)
$.. ==&gt; "67"
</pre>

<p>Here is <tt>lcg337</tt> followed by a series of incremental
generators.

</p><pre>jshell&gt; Function&lt;String,Rand&lt;String&gt;&gt; g = x -&gt; RandInt.of(y -&gt; y + 1).map(y -&gt; x + y)
g ==&gt; $Lambda..

jshell&gt; lcg337.map(x -&gt; x.toString()).flatMap(g).flatMap(g).flatMap(g).seed(1)
$.. ==&gt; "6789"
</pre>

<p>Sample runs below demonstrate the application of the laws of the Monad involving <tt>flatMap</tt>.

</p><pre>jshell&gt; Function&lt;Integer,Rand&lt;Integer&gt;&gt; id = x -&gt; RandInt.of(y -&gt; y) // identity generator
id ==&gt; $Lambda..

jshell&gt; lcg337.seed(1)
$.. ==&gt; 6

jshell&gt; lcg337.flatMap(id).seed(1)
$.. ==&gt; 6

jshell&gt; Function&lt;Integer,Rand&lt;Integer&gt;&gt; h = x -&gt; lcg337.map(y -&gt; x + y)
h ==&gt; $Lambda..

jshell&gt; id.apply(1).flatMap(h).seed(1)
$.. ==&gt; 7

jshell&gt; h.apply(1).seed(1)
$.. ==&gt; 7

jshell&gt; lcg337.map(x -&gt; x.toString()).flatMap(f).flatMap(g).seed(1)
$.. ==&gt; "601"

jshell&gt; lcg337.map(x -&gt; x.toString()).flatMap(x -&gt; f.apply(x).flatMap(g)).seed(1)
$.. ==&gt; "601"
</pre>

<p>Once again you are reminded that for simplicity of
implementation and grading, do not use bounded wildcards.

</p><h2>Level 4</h2>

<p>Now we need to ensure the minimal evaluation of our computation
context.

</p><pre>jshell&gt; RandInt lcg337 = RandInt.of(x -&gt; { 
   ...&gt;    int z = (3 * x + 3) % 7; 
   ...&gt;    System.out.println("lcg:" + z); return z;})
lcg337 ==&gt; RandInt

jshell&gt; lcg337.seed(1)
lcg:6
$.. ==&gt; 6

jshell&gt; Function&lt;Integer,Integer&gt; j = x -&gt; { 
   ...&gt;    System.out.println("beep"); return x + 10;}
j ==&gt; $Lambda..

jshell&gt; lcg337.map(j).seed(1)
lcg:6
beep
$.. ==&gt; 16

jshell&gt; lcg337.map(j).map(j).seed(1)
lcg:6
beep
beep
$.. ==&gt; 26
</pre>

<p>The following is a check on the minimal evaluation of
<tt>flatMap</tt>.

</p><pre>jshell&gt; Function&lt;Integer,Rand&lt;Integer&gt;&gt; k = x -&gt; {
   ...&gt;    System.out.println("beep"); 
   ...&gt;    return lcg337.map(y -&gt; x + y);}
k ==&gt; $Lambda..

jshell&gt; lcg337.flatMap(k).seed(1)
lcg:6
beep
lcg:0
$.. ==&gt; 6

jshell&gt; lcg337.flatMap(k).flatMap(k).seed(1)
lcg:6
beep
lcg:0
beep
lcg:3
$.. ==&gt; 9
</pre>

<h2>Level 5</h2>

<p>Let us use our random number generator to simulate a simplified version of the birthday paradox.  

</p><blockquote>
<p><i>How many people must there be in a group so as to have a fifty
percent chance of having two persons with the same birth month?</i>
</p>
</blockquote>

<p>In this example, we shall use the following linear congruential
generator:

</p><pre>jshell&gt; RandInt lcg31511 = RandInt.of(x -&gt; (31 * x + 31) % 511)
lcg31511 ==&gt; RandInt
</pre>

<p>In <tt>level5.jsh</tt>, write a function <tt>sameMonth</tt> that
takes in a <tt>RandInt</tt> generator <tt>gen</tt>, a group size <tt>n</tt>, and seed value for random number generation <tt>s</tt>, and returns <tt>true</tt> if there are at least two people in the group with the same sameMonth, or <tt>false</tt> otherwise.

</p><p>Note that for each random number generated <tt>x</tt>, the
expression <tt>x % 12</tt> 
will result in a value between <tt>0</tt> and
<tt>11</tt> which can be used to represent the month.
You will need to follow this strictly; otherwise the outcome will not be the same.
Moreover, do not include the seed as the first value of the random
sequence; otherwise the first value is not random.

</p><pre>jshell&gt; sameMonth(lcg31511, 4, 1)
$.. ==&gt; true

jshell&gt; InfList.iterate(0, x -&gt; x + 1).
   ...&gt; takeWhile(x -&gt; x &lt; 20).
   ...&gt; map(x -&gt; new Pair&lt;&gt;(x, sameMonth(lcg31511, 4, x))).
   ...&gt; forEach(x -&gt; System.out.println(x))
Pair[t=0, u=true]
Pair[t=1, u=true]
Pair[t=2, u=true]
Pair[t=3, u=false]
Pair[t=4, u=true]
Pair[t=5, u=true]
Pair[t=6, u=true]
Pair[t=7, u=false]
Pair[t=8, u=true]
Pair[t=9, u=true]
Pair[t=10, u=false]
Pair[t=11, u=true]
Pair[t=12, u=true]
Pair[t=13, u=false]
Pair[t=14, u=false]
Pair[t=15, u=false]
Pair[t=16, u=true]
Pair[t=17, u=false]
Pair[t=18, u=false]
Pair[t=19, u=false]
</pre>

<p>The above shows the simulation for twenty trials.  As the simulation
trials increase, the probability of two person in the group having
the same birth month converges.  Repeating the simulation for
different group sizes <tt>n</tt>, one can find the minimum group size
with a fifty percent chance of two persons with the same birth month.
This is left as an extra exercise for you.

<!--
<h2>Scratch</h2>
<pre>
jshell&gt; Function&lt;InfList&lt;Integer&gt;,Rand&lt;InfList&lt;Integer&gt;&gt;&gt; f = x -&gt; lcg337.map(y -&gt; x.concat(InfList.of(y)))
f ==&gt; $Lambda..

jshell&gt; lcg337.map(x -&gt; InfList.of(x)).
   ...&gt; flatMap(f).flatMap(f).seed(1).forEach(x - &gt; System.out.println(x))
6
0
3

jshell&gt; InfList.iterate(1, x -&gt; x + 1).limit(5).
   ...&gt; map(x -&gt; f).
   ...&gt; reduce(lcg337.map(x -&gt; InfList.of(x)), (x,y) -&gt; x.flatMap(y)).seed(1).forEach(x -&gt; System.out.println(x))
6
0
3
5
4
1
</pre>

<p>Here is one class of 23 students in birthday paradox.

<pre>
jshell&gt; RandInt lcg31511 = RandInt.of(x -&gt; (31 * x) % 511)
lcg31511 ==&gt; RandInt

jshell&gt; Function&lt;InfList&lt;Integer&gt;,Rand&lt;InfList&lt;Integer&gt;&gt;&gt; f = x -&gt; lcg31511.map(
y -&gt; x.concat(InfList.of(y)))
f ==&gt; $Lambda..

jshell&gt; InfList.iterate(1, x -&gt; x + 1).limit(23).
   ...&gt; map(x -&gt; f).
   ...&gt; reduce(lcg31511.map(x -&gt; InfList.of(x)), (x,y) -&gt; x.flatMap(y)).seed(1).
   ...&gt; forEach(x -&gt; System.out.print(x + " "))
31 450 153 144 376 414 59 296 489 340 320 211 409 415 90 235 131 484 185 114 468 200 68 64
</pre>

<p>With a pair.

<pre>
jshell&gt; Function&lt;Pair&lt;Integer,Integer&gt;, Rand&lt;Pair&lt;Integer,Integer&gt;&gt;&gt; f = x -&gt; lcg31511.map(y -&gt; new Pair&lt;&gt;(x.t() + 1,y % 365))
f ==&gt; $Lambda..

jshell&gt; lcg31511.map(x -&gt; new Pair&lt;&gt;(1, x % 365)).flatMap(f).seed(1)
$.. ==&gt; Pair[t=2, u=85]

jshell&gt; Function&lt;Pair&lt;Integer,Integer&gt;, Rand&lt;Pair&lt;Integer,Integer&gt;&gt;&gt; f = x -&gt; lcg31511.map(y -&gt; new Pair&lt;&gt;(x.t() + 1,y % 365))
f ==&gt; $Lambda..

jshell&gt; lcg31511.map(x -&gt; new Pair&lt;&gt;(1, x % 365)).flatMap(f).seed(1)
$.. ==&gt; Pair[t=2, u=85]

jshell&gt; lcg31511.map(x -&gt; new Pair&lt;&gt;(1, x % 365)).seed(1)
$.. ==&gt; Pair[t=1, u=31]

jshell&gt; lcg31511.map(x -&gt; new Pair&lt;&gt;(1, x % 365)).flatMap(f).seed(1)
$.. ==&gt; Pair[t=2, u=85]

jshell&gt; lcg31511.map(x -&gt; new Pair&lt;&gt;(1, x % 365)).flatMap(f).flatMap(f).seed(1)
$.. ==&gt; Pair[t=3, u=153]
</pre>



<p>Write a class <tt>RandSeq</tt> with an <tt>of</tt> method that
takes in a function that takes in three integer arguments <tt>a</tt>,
<tt>c</tt> and <tt>n</tt> (linear congruential) and generates a
<tt>RandSeq</tt> object.  Just like <tt>Rand</tt>, random
generation proceeds with the <tt>seed</tt> method.

<p>Just like an infinite list (or stream), the number of elements
generated can be controlled by <tt>limit</tt>.


-->
		</p>