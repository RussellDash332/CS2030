<h3>Zork!!</h3>
<a href="https://russelldash332.github.io/CS2030/">Back to homepage</a>
<!--
<h4>Topic Coverage</h4>
<ul>
</ul>
-->
<p><strong>This PE is worth 20% of your grade. You must work on it alone, without discussing with anyone (whether online or offline).</strong></p>
<h4>Problem Description</h4>
<p>If you think that a computer game requires stunning graphics, or least, cute ones, to be captivating, then you haven't played Zork.  Created in the late 1970s, before sound cards or graphics cards were invented, Zork was a text-only adventure game famed for its storytelling and advanced text parser.  In it, you play the role of an explorer plonked in front of a house, surrounded by a forest, with no hint of what your goal might be: whether to rescue an imprisoned princess, or to find hidden treasure.</p>
<p>You interact by typing commands, such as "GO NORTH", or "HIT THE TROLL WITH THE ELVISH SWORD", and the game responds with textual descriptions, such as "Phosphorescent mosses, fed by a trickle of water from some unseen source above, make the crystal grotto glow and sparkle with every color of the rainbow‚Äù.  These words spark one's imagination of mystery, fear, and adventure in ways that graphics and sound cannot.</p>
<p>Its commercial launch was a great success, spawning a trilogy (because otherwise the entire game could not fit into computer memory) that in total sold over 800,000 copies, and keeping it among the "Top 50 Games of All Time" even twenty years later. Zork foreshadowed, and influenced, the development of modern AI chatbots.</p>
<p>In this Practical Assessment (PA), you will create the basic game elements in Zork.  While keeping it simple to fit the needs of a PA, there is great scope for future development into a much richer project for educational purpose (<em>read: talk to the Profs if you are interested</em>).</p>
<h4>Task</h4>
<p>In this task, you are only required to work with three things: a candle, a sword and a troll. These things are placed at possibly different rooms. The objective is to simulate and test different scenarios of game play.  Take note of the following:</p>
<ul>
<li>all Java objects constructed are to be <em>immutable</em>; </li>
<li>for simplicity, at no time will there be multiple things of the same type </li>
</ul>
<p>This task is divided into several levels.  You need to complete all levels. Read through all the levels  to see how the different levels are related.</p>
<p>Remember to:</p>
<ul>
<li>write each class/interface/enum in a separate <tt>.java</tt> file </li>
<li>always compile your program files first before using <tt>jshell</tt> to test your program </li>
<li>declare object properties starting with <tt>private final</tt> or <tt>protected final</tt> </li>
<li>you may import any Java package; however do not use the wild card <tt>*</tt> in your import statements, else CodeCrunch will render your program uncompilable </li>
<li>all tests use valid arguments; you need not check for validity of arguments; <tt>null</tt> will not be used for the tests <!--
<li>use <tt>checkstyle</tt> and <tt>javadoc</tt> comments to enhance code readability and facilitating code review --> </li>
</ul>
<p><!-- 
<table border=1 cellpadding=10>
<tr>
<td>--></p>
<h4>Level 1</h4>
<p>Write a class <tt>Room</tt> to represent a room in the game. Things can be placed in a room. In this level, we shall place a <tt>Candle</tt> in the foyer. To simulate the passing of time, a method <tt>tick()</tt> in class <tt>Room</tt> is called.</p>
<p>With respect to the candle, every tick causes the candle to change state.The following are the state changes of the candle.</p>
<ul>
<li><tt>Candle flickers.</tt> </li>
<li><tt>Candle is getting shorter.</tt> </li>
<li><tt>Candle is about to burn out.</tt> </li>
<li><tt>Candle has burned out.</tt> </li>
</ul>
<p>Note that any <tt>tick</tt>s beyond the last state of the candle causes it to remain in it's final state. Also, make sure that <tt>Room</tt> does not sub-class from any other class (apart from <tt>Object</tt> of course).</p>
<p>&nbsp;</p>
<pre>$ javac your_java_files
$ jshell -q your_java_files_in_bottom-up_dependency_order &lt; test1.jsh
<strong>jshell&gt; new Room("foyer");</strong>
$.. ==&gt; @foyer
<strong>jshell&gt; new Room("foyer").add(new Candle());</strong>
$.. ==&gt; @foyer
Candle flickers.
<strong>jshell&gt; new Room("foyer").add(new Candle()).tick()</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
<strong>jshell&gt; new Room("foyer").add(new Candle()).tick().tick()</strong>
$.. ==&gt; @foyer
Candle is about to burn out.
<strong>jshell&gt; new Room("foyer").add(new Candle()).tick().tick().tick()</strong>
$.. ==&gt; @foyer
Candle has burned out.
<strong>jshell&gt; new Room("foyer").add(new Candle()).tick().tick().tick().tick()</strong>
$.. ==&gt; @foyer
Candle has burned out.
<strong>jshell&gt; /exit</strong>
</pre>
<h4>Level 2</h4>
<p>Let's now include two more things, <tt>Troll</tt> and <tt>Sword</tt>, into our room. Just like the candle, each of these things have their own states:</p>
<ul>
<li>For the Troll: 
<ul>
<li><tt>Troll lurks in the shadows.</tt> </li>
<li><tt>Troll is getting hungry.</tt> </li>
<li><tt>Troll is VERY hungry.</tt> </li>
<li><tt>Troll is SUPER HUNGRY and is about to ATTACK!</tt> </li>
<li><tt>Troll attacks!</tt> </li>
</ul>
</li>
<li>For the Sword: 
<ul>
<li><tt>Sword is shimmering.</tt> </li>
</ul>
</li>
</ul>
<p>Things are output in order of which they are added into the room. Also note that your program should be flexible enough for other things to be included in future.</p>
<pre>$ javac your_java_files
$ jshell -q your_java_files_in_bottom-up_dependency_order &lt; test2.jsh
<strong>jshell&gt; Room foyer = new Room("foyer").add(new Candle()).add(new Troll())</strong>
<strong>jshell&gt; Stream.iterate(foyer, x -&gt; x.tick()).limit(6).forEach(System.out::println)</strong>
@foyer
Candle flickers.
Troll lurks in the shadows.
@foyer
Candle is getting shorter.
Troll is getting hungry.
@foyer
Candle is about to burn out.
Troll is VERY hungry.
@foyer
Candle has burned out.
Troll is SUPER HUNGRY and is about to ATTACK!
@foyer
Candle has burned out.
Troll attacks!
@foyer
Candle has burned out.
Troll attacks!
<strong>jshell&gt; foyer = foyer.add(new Sword())</strong>
<strong>jshell&gt; Stream.iterate(foyer, x -&gt; x.tick()).limit(3).forEach(System.out::println)</strong>
@foyer
Candle flickers.
Troll lurks in the shadows.
Sword is shimmering.
@foyer
Candle is getting shorter.
Troll is getting hungry.
Sword is shimmering.
@foyer
Candle is about to burn out.
Troll is VERY hungry.
Sword is shimmering.
<strong>jshell&gt; foyer</strong>
foyer ==&gt; @foyer
Candle flickers.
Troll lurks in the shadows.
Sword is shimmering.
<strong>jshell&gt; /exit</strong>
</pre>
<h4>Level 3</h4>
<p>Now, we are ready to interact with the objects. An interaction occurs by passing an action into an overloaded <tt>tick</tt> method that takes one argument. The action is in the form of a lambda that describes what actions to take on one or more things.</p>
<p>As an example, we can pass a dummy action <tt>x -&gt; x</tt> (the identity lambda) into <tt>tick</tt>. The test will take the following form:</p>
<pre><strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Sword()).tick(x -&gt; x)</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
Sword is shimmering.
</pre>
<p>As you can see, applying the dummy action above results in the same behaviour as</p>
<pre><strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Sword()).tick()</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
Sword is shimmering.
</pre>
<p>In addition, write the action <tt>takeSword</tt> into the file <tt>actions.jsh</tt>.   Note that this will result in three different outputs (see sample run below) according to the state of things in the room. These output (prepended with <tt>"--&gt;"</tt>) must be specified within <tt>actions.jsh</tt> and not in the individual classes. You may choose any suitable types for the lambda.</p>
<pre>$ javac your_java_files
$ jshell -q your_java_files_in_bottom-up_dependency_order actions.jsh &lt; test3.jsh
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Sword()).tick(x -&gt; x)</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Sword()).tick(x -&gt; x).tick(x -&gt; x)</strong>
$.. ==&gt; @foyer
Candle is about to burn out.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Sword()).tick(takeSword)</strong>
--&gt; You have taken sword.
$.. ==&gt; @foyer
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Sword()).tick(takeSword).tick(takeSword)</strong>
--&gt; You have taken sword.
--&gt; You already have sword.
$.. ==&gt; @foyer
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").tick(takeSword)</strong>
--&gt; There is no sword.
$.. ==&gt; @foyer
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick()</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
Troll is getting hungry.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick(x -&gt; x)</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
Troll is getting hungry.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick().tick(x -&gt; x)</strong>
$.. ==&gt; @foyer
Candle is about to burn out.
Troll is VERY hungry.
Sword is shimmering.
<strong>jshell&gt; /exit</strong>
</pre>
<h4>Level 4</h4>
<p>Now add another action <tt>killTroll</tt> into <tt>actions.jsh</tt>. Look at the sample runs below for the behaviour of the action. Once again, the output (prepended with <tt>"--&gt;"</tt>) must be specified in <tt>actions.jsh</tt> and not in the respective class files. Also note that a killed troll will vanish from the room.</p>
<pre>$ javac your_java_files
$ jshell -q your_java_files_in_bottom-up_dependency_order actions.jsh &lt; test4.jsh
<strong>jshell&gt; new Room("foyer").add(new Sword()).tick(killTroll)</strong>
--&gt; There is no troll
$.. ==&gt; @foyer
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Sword()).add(new Troll()).tick(killTroll)</strong>
--&gt; You have no sword.
$.. ==&gt; @foyer
Sword is shimmering.
Troll is getting hungry.
<strong>jshell&gt; new Room("foyer").add(new Sword()).add(new Troll()).tick(takeSword).tick(killTroll)</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
$.. ==&gt; @foyer
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick().tick(takeSword)</strong>
--&gt; You have taken sword.
$.. ==&gt; @foyer
Candle is about to burn out.
Troll is VERY hungry.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick().tick(takeSword).tick(killTroll)</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
$.. ==&gt; @foyer
Candle has burned out.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick().tick(killTroll)</strong>
--&gt; You have no sword.
$.. ==&gt; @foyer
Candle is about to burn out.
Troll is VERY hungry.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick().tick(killTroll).tick(takeSword)</strong>
--&gt; You have no sword.
--&gt; You have taken sword.
$.. ==&gt; @foyer
Candle has burned out.
Troll is SUPER HUNGRY and is about to ATTACK!
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).add(new Sword()).tick().tick(killTroll).tick(takeSword).tick(killTroll)</strong>
--&gt; You have no sword.
--&gt; You have taken sword.
--&gt; Troll is killed.
$.. ==&gt; @foyer
Candle has burned out.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Candle()).add(new Troll()).tick(killTroll)</strong>
--&gt; You have no sword.
$.. ==&gt; @foyer
Candle is getting shorter.
Troll is getting hungry.
<strong>jshell&gt; /exit</strong>
</pre>
<h4>Level 5</h4>
<p>We are now ready to venture into other rooms.   Going into a room requires that a room be created first. This is done via the <tt>go</tt> method that takes in another lambda of the form <tt>x -&gt; new Room...</tt>.  As an example, we can represent <em>deja vu</em> with the following test:</p>
<pre><strong>jshell&gt; new Room("dining").add(new Candle()).add(new Sword())</strong>
$.. ==&gt; @dining
Candle flickers.
Sword is shimmering.
<strong>jshell&gt; new Room("dining").add(new Candle()).add(new Sword()).go(x -&gt; new Room("mystery", x))</strong>
$.. ==&gt; @mystery
Candle flickers.
Sword is shimmering.
</pre>
<p>Notice that this new mystery room that we just entered looks like the same room before! Not only that we can also bring an item that we picked into a new room.</p>
<pre><strong>jshell&gt; new Room("foyer").add(new Sword()).tick(takeSword).go(x -&gt; new Room("dining").add(new Candle()))</strong>
--&gt; You have taken sword.
$.. ==&gt; @dining
Sword is shimmering.
Candle flickers.
</pre>
<p>Note that things brought into a new room are listed first.</p>
<pre>$ javac your_java_files
$ jshell -q your_java_files_in_bottom-up_dependency_order actions.jsh &lt; test5.jsh
<strong>jshell&gt; new Room("dining").add(new Candle()).add(new Sword())</strong>
$.. ==&gt; @dining
Candle flickers.
Sword is shimmering.
<strong>jshell&gt; new Room("dining").add(new Candle()).add(new Sword()).go(x -&gt; new Room("mystery", x))</strong>
$.. ==&gt; @mystery
Candle flickers.
Sword is shimmering.
<strong>jshell&gt; new Room("dining").add(new Candle()).tick().add(new Sword()).go(x -&gt; new Room("mystery", x))</strong>
$.. ==&gt; @mystery
Candle is getting shorter.
Sword is shimmering.
<strong>jshell&gt; new Room("foyer").add(new Sword()).tick(takeSword).go(x -&gt; new Room("dining").add(new Candle()))</strong>
--&gt; You have taken sword.
$.. ==&gt; @dining
Sword is shimmering.
Candle flickers.
<strong>jshell&gt; Room r1 = new Room("foyer").add(new Candle())</strong>
<strong>jshell&gt; Room r2 = r1.go(x -&gt; new Room("library").add(new Sword()))</strong>
<strong>jshell&gt; Room r3 = r2.go(x -&gt; new Room("dining").add(new Troll()))</strong>
<strong>jshell&gt; r3.tick(killTroll)</strong>
--&gt; You have no sword.
$.. ==&gt; @dining
Troll is getting hungry.
<strong>jshell&gt; r2.tick(takeSword).go(x -&gt; new Room("dining").add(new Candle()).add(new Troll()))</strong>
--&gt; You have taken sword.
$.. ==&gt; @dining
Sword is shimmering.
Candle flickers.
Troll lurks in the shadows.
<strong>jshell&gt; r2.tick(takeSword).go(x -&gt; new Room("dining").add(new Candle()).add(new Troll())).tick(killTroll)</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
$.. ==&gt; @dining
Sword is shimmering.
Candle is getting shorter.
<strong>jshell&gt; r1.go(x -&gt; new Room("library").</strong>
<strong>   ...&gt; add(new Sword()).</strong>
<strong>   ...&gt; tick(takeSword).</strong>
<strong>   ...&gt; go(y -&gt; new Room("dining").add(new Candle()).add(new Troll()))).tick(killTroll)</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
$.. ==&gt; @dining
Sword is shimmering.
Candle is getting shorter.
<strong>jshell&gt; /exit</strong>

</pre>
<h4>Level 6</h4>
<p>Finally, we would like to go back to the previous rooms. For simplicity, once we come back from a room, the room that we came back from vanishes, so we can't go into it again. Note that when you return from room B to room A, things in room A are output first, followed by B (this is to be consistent with the output in the previous level dealing with <tt>go</tt>). That is to say, things in the room that is created earlier are always listed first. Also note that once we enter into a new room, and return from it, time in the original room ticks only once.</p>
<p>Lastly, add an action <tt>dropSword</tt> to drop the sword.</p>
<pre>$ javac your_java_files
$ jshell -q your_java_files_in_bottom-up_dependency_order actions.jsh &lt; test6.jsh
<strong>jshell&gt; Room r1 = new Room("foyer").add(new Candle())</strong>
<strong>jshell&gt; Room r2 = r1.go(x -&gt; new Room("dining").add(new Troll()))</strong>
<strong>jshell&gt; Room r3 = r2.go(x -&gt; new Room("library").add(new Sword()))</strong>
<strong>jshell&gt; r1</strong>
r1 ==&gt; @foyer
Candle flickers.
<strong>jshell&gt; r2</strong>
r2 ==&gt; @dining
Troll lurks in the shadows.
<strong>jshell&gt; r2.back()</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
<strong>jshell&gt; r2.tick().tick().tick()</strong>
$.. ==&gt; @dining
Troll is SUPER HUNGRY and is about to ATTACK!
<strong>jshell&gt; r2.tick().tick().tick().back()</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
<strong>jshell&gt; r3</strong>
r3 ==&gt; @library
Sword is shimmering.
<strong>jshell&gt; r3.back()</strong>
$.. ==&gt; @dining
Troll is getting hungry.
<strong>jshell&gt; r3.back().back()</strong>
$.. ==&gt; @foyer
Candle is getting shorter.
<strong>jshell&gt; r3.tick(takeSword).back().tick(killTroll).back()</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
$.. ==&gt; @foyer
Candle is getting shorter.
Sword is shimmering.
<strong>jshell&gt; r3.tick(takeSword).back().tick(killTroll).tick(dropSword)</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
--&gt; You have dropped sword.
$.. ==&gt; @dining
Sword is shimmering.
<strong>jshell&gt; r3.tick(takeSword).back().tick(killTroll).tick(dropSword).back()</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
--&gt; You have dropped sword.
$.. ==&gt; @foyer
Candle is getting shorter.
<strong>jshell&gt; r1.go(x -&gt; new Room("dining").add(new Troll())).</strong>
<strong>   ...&gt; tick().</strong>
<strong>   ...&gt; go(x -&gt; new Room("library").add(new Sword())).</strong>
<strong>   ...&gt; tick().</strong>
<strong>   ...&gt; tick(takeSword).</strong>
<strong>   ...&gt; back().</strong>
<strong>   ...&gt; tick().</strong>
<strong>   ...&gt; tick(killTroll)</strong>
--&gt; You have taken sword.
--&gt; Troll is killed.
$.. ==&gt; @dining
Sword is shimmering.
<strong>jshell&gt; /exit</strong>

</html>